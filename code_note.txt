# 注意点：带日志的版本仅用于调试，不要在leetcode上提交，会超时

二叉树

#0：二叉树，大体分为4类：
		满二叉树：每个节点都是满的；即：深度为k，节点数为(2^k - 1)
		完全二叉树：“除了最底层节点可能没填满外”，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置
					即深度为k，节点数为1  ~  (2^k - 1)
		二叉搜索树（BST）：满二叉树和完全二叉树都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树（左节点<中节点值<右节点值），对树的形状没有要求。(注意二叉搜索树中不能有重复元素。)
		平衡二叉搜索树（AVL）：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树（平衡：就是说要么有节点，要么没有）。
	
#0.1：二叉树可以链式存储（指针），也可以顺序存储（数组）

		当用数组表示时：如果父节点的数组下标是i，那么它的左孩子就是i * 2 + 1，右孩子就是 i * 2 + 2。--------该方法的根节点的下标是0

		当用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

# 0.2：其实红黑树就是一种平衡二叉搜索树，这两个树不是独立的，
        所以C++中map、multimap、set、multiset的底层实现机制是二叉平衡搜索树，再具体一点是红黑树。

# 0.3：二叉树 节点的度：就是一个节点的分支数，比如说一个节点的度为0，则说明该节点没有分支，说一个节点的度为2，则说明该节点有两个分支
       二叉树的 深度：深度分为最大深度和最小深度，最大深度就是从根节点到最下面的一个节点的层数，层数K>=1
                                              最小深度就是从根节点到最近的节点的度为0的层数

# 0.4：根节点的高度就是二叉树的最大深度

# 0.5：二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
	   二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。
	   高度+深度=该二叉树的层数
	
	   高度和深度的计算中：leetcode中都是以节点为一度，但维基百科上的是边为一度，暂时以leetcode为准-----（也就是说，上面说的边的条数，其实就是节点的个数）
	   
# 1：深度优先搜索 遍历方式：前中后序遍历----一般使用递归或迭代（栈），尽量不要使用递归（用栈来实现递归的写法，也就是所谓的迭代法）
	 广度优先搜索 遍历方式：层序遍历----用队列

# 2：递归算法的三个要素。
	1）确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 
									并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

	2）确定终止条件： 如果递归没有终止，操作系统的内存栈必然就会溢出。

	3）确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

# 3：递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中

# 4：叶子节点：是指没有子节点的节点

# 5：深度遍历后的结果是只是一个列表，
     而层序遍历后的结果是列表的嵌套，也就是说每一层都会是一个列表，多层那就是一个列表里包含多个子列表

# 6：因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）

	有的同学一定疑惑，为什么 104.二叉树的最大深度 中求的是二叉树的最大深度，也用的是后序遍历。
	那是因为代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。

# 7：冒号和等于号组合在一起 ( a := f(x) ) 相当于赋值，常用在函数中节省代码

# 8：返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

    如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
    如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先中介绍）
    如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

    如果要搜索一条边，递归函数就要加返回值，这里也是一样的道理。
    因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。（700.二叉搜索树的搜索）

# 9：常用特性：
	 二叉搜索树具有顺序，采用中序遍历就可以实现从小到达的排序
	 后序遍历是一种自顶向上的过程，首先处理的是叶子节点

回溯

# 9：回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案（一些问题能暴力搜出来就不错了）
        回溯法，一般可以解决如下几种问题：
        组合问题（C）：N个数里面按一定规则找出k个数的集合
        切割问题：一个字符串按一定规则有几种切割方式
        子集问题：一个N个数的集合里有多少符合条件的子集
        排列问题（A）：N个数按一定规则全排列，有几种排列方式
        棋盘问题：N皇后，解数独等等

# 10：回溯法就用递归来解决嵌套层数的问题（每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了）

# 11：每次都想要最好的，那就是贪心

# 12：在结果不知道具体大小时，有需要进行比较时，常常会用到无穷小：-float('inf')

# 13：动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。
      所以动态规划中每一个状态一定是由 上一个状态 推导 出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

      确定dp数组（dp table）以及下标的含义
      确定递推公式
      dp数组如何初始化
      确定遍历顺序
      举例推导dp数组

      如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。
      如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

#14：动态规划中：
     强调的是组合C那就是外层for循环遍历物品，内层for遍历背包。
     强调的是排列A就是外层for遍历背包，内层for循环遍历物品。
     若不在意，则都可以

     若是 01背包，那么内层就需要 倒序
     若是 完全背包，那么内层就需要 正序

     若递归公式中是min，那么我们在初始化元素时，一般先预定为最大值INX_MAX   ==》那么在这种情况下，其实内层外层时物品还是背包已经无所谓了
     若递归公式中是max，那么我们在初始化元素时，一般先预定为最小值0  ===>得看题目限定的最大值是多少

    递归公式中，比如dp[i] = max(dp[i], xxx)   其中右边的dp[i]就是初始化时的数值




